/*
 * openHAB REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 8
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{Error, configuration};
use crate::apis::ContentType;
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
#[cfg(feature = "mockall")]
use mockall::automock;
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use std::sync::Arc;

#[cfg_attr(feature = "mockall", automock)]
#[async_trait]
pub trait VoiceApi: Send + Sync {
    /// GET /voice/defaultvoice
    ///
    ///
    async fn get_default_voice(&self) -> Result<models::VoiceDto, Error<GetDefaultVoiceError>>;

    /// GET /voice/interpreters/{id}
    ///
    ///
    async fn get_voice_interpreter_by_uid<'id, 'accept_language>(
        &self,
        id: &'id str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<Vec<models::HumanLanguageInterpreterDto>, Error<GetVoiceInterpreterByUidError>>;

    /// GET /voice/interpreters
    ///
    ///
    async fn get_voice_interpreters<'accept_language>(
        &self,
        accept_language: Option<&'accept_language str>,
    ) -> Result<Vec<models::HumanLanguageInterpreterDto>, Error<GetVoiceInterpretersError>>;

    /// GET /voice/voices
    ///
    ///
    async fn get_voices(&self) -> Result<Vec<models::VoiceDto>, Error<GetVoicesError>>;

    /// POST /voice/interpreters/{ids}
    ///
    ///
    async fn interpret_text<'ids, 'body, 'accept_language>(
        &self,
        ids: Vec<String>,
        body: &'body str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<String, Error<InterpretTextError>>;

    /// POST /voice/interpreters
    ///
    ///
    async fn interpret_text_by_default_interpreter<'body, 'accept_language>(
        &self,
        body: &'body str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<String, Error<InterpretTextByDefaultInterpreterError>>;

    /// POST /voice/listenandanswer
    ///
    ///
    async fn listen_and_answer<
        'accept_language,
        'source_id,
        'stt_id,
        'tts_id,
        'voice_id,
        'hli_ids,
        'sink_id,
        'listening_item,
    >(
        &self,
        accept_language: Option<&'accept_language str>,
        source_id: Option<&'source_id str>,
        stt_id: Option<&'stt_id str>,
        tts_id: Option<&'tts_id str>,
        voice_id: Option<&'voice_id str>,
        hli_ids: Option<Vec<String>>,
        sink_id: Option<&'sink_id str>,
        listening_item: Option<&'listening_item str>,
    ) -> Result<(), Error<ListenAndAnswerError>>;

    /// POST /voice/dialog/start
    ///
    ///
    async fn start_dialog<
        'accept_language,
        'source_id,
        'ks_id,
        'stt_id,
        'tts_id,
        'voice_id,
        'hli_ids,
        'sink_id,
        'keyword,
        'listening_item,
    >(
        &self,
        accept_language: Option<&'accept_language str>,
        source_id: Option<&'source_id str>,
        ks_id: Option<&'ks_id str>,
        stt_id: Option<&'stt_id str>,
        tts_id: Option<&'tts_id str>,
        voice_id: Option<&'voice_id str>,
        hli_ids: Option<&'hli_ids str>,
        sink_id: Option<&'sink_id str>,
        keyword: Option<&'keyword str>,
        listening_item: Option<&'listening_item str>,
    ) -> Result<(), Error<StartDialogError>>;

    /// POST /voice/dialog/stop
    ///
    ///
    async fn stop_dialog<'source_id>(
        &self,
        source_id: Option<&'source_id str>,
    ) -> Result<(), Error<StopDialogError>>;

    /// POST /voice/say
    ///
    ///
    async fn text_to_speech<'body, 'voiceid, 'sinkid, 'volume>(
        &self,
        body: &'body str,
        voiceid: Option<&'voiceid str>,
        sinkid: Option<&'sinkid str>,
        volume: Option<&'volume str>,
    ) -> Result<(), Error<TextToSpeechError>>;
}

pub struct VoiceApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl VoiceApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

#[async_trait]
impl VoiceApi for VoiceApiClient {
    async fn get_default_voice(&self) -> Result<models::VoiceDto, Error<GetDefaultVoiceError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/defaultvoice", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to `models::VoiceDto`",
                    )));
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `models::VoiceDto`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<GetDefaultVoiceError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_voice_interpreter_by_uid<'id, 'accept_language>(
        &self,
        id: &'id str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<Vec<models::HumanLanguageInterpreterDto>, Error<GetVoiceInterpreterByUidError>>
    {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/voice/interpreters/{id}",
            local_var_configuration.base_path,
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HumanLanguageInterpreterDto&gt;`",
                    )));
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `Vec&lt;models::HumanLanguageInterpreterDto&gt;`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<GetVoiceInterpreterByUidError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_voice_interpreters<'accept_language>(
        &self,
        accept_language: Option<&'accept_language str>,
    ) -> Result<Vec<models::HumanLanguageInterpreterDto>, Error<GetVoiceInterpretersError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/interpreters", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HumanLanguageInterpreterDto&gt;`",
                    )));
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `Vec&lt;models::HumanLanguageInterpreterDto&gt;`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<GetVoiceInterpretersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_voices(&self) -> Result<Vec<models::VoiceDto>, Error<GetVoicesError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/voices", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::VoiceDto&gt;`",
                    )));
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `Vec&lt;models::VoiceDto&gt;`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<GetVoicesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn interpret_text<'ids, 'body, 'accept_language>(
        &self,
        ids: Vec<String>,
        body: &'body str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<String, Error<InterpretTextError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/voice/interpreters/{ids}",
            local_var_configuration.base_path,
            ids = ids.join(",")
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Ok(local_var_content),
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `String`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<InterpretTextError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn interpret_text_by_default_interpreter<'body, 'accept_language>(
        &self,
        body: &'body str,
        accept_language: Option<&'accept_language str>,
    ) -> Result<String, Error<InterpretTextByDefaultInterpreterError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/interpreters", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => return Ok(local_var_content),
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be converted to `String`"
                    ))));
                }
            }
        } else {
            let local_var_entity: Option<InterpretTextByDefaultInterpreterError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn listen_and_answer<
        'accept_language,
        'source_id,
        'stt_id,
        'tts_id,
        'voice_id,
        'hli_ids,
        'sink_id,
        'listening_item,
    >(
        &self,
        accept_language: Option<&'accept_language str>,
        source_id: Option<&'source_id str>,
        stt_id: Option<&'stt_id str>,
        tts_id: Option<&'tts_id str>,
        voice_id: Option<&'voice_id str>,
        hli_ids: Option<Vec<String>>,
        sink_id: Option<&'sink_id str>,
        listening_item: Option<&'listening_item str>,
    ) -> Result<(), Error<ListenAndAnswerError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/voice/listenandanswer",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sourceId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stt_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sttId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = tts_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("ttsId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = voice_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("voiceId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = hli_ids {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(
                    &local_var_str
                        .into_iter()
                        .map(|p| ("hliIds".to_owned(), p.to_string()))
                        .collect::<Vec<(std::string::String, std::string::String)>>(),
                ),
                _ => local_var_req_builder.query(&[(
                    "hliIds",
                    &local_var_str
                        .into_iter()
                        .map(|p| p.to_string())
                        .collect::<Vec<String>>()
                        .join(",")
                        .to_string(),
                )]),
            };
        }
        if let Some(ref local_var_str) = sink_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sinkId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = listening_item {
            local_var_req_builder =
                local_var_req_builder.query(&[("listeningItem", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ListenAndAnswerError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn start_dialog<
        'accept_language,
        'source_id,
        'ks_id,
        'stt_id,
        'tts_id,
        'voice_id,
        'hli_ids,
        'sink_id,
        'keyword,
        'listening_item,
    >(
        &self,
        accept_language: Option<&'accept_language str>,
        source_id: Option<&'source_id str>,
        ks_id: Option<&'ks_id str>,
        stt_id: Option<&'stt_id str>,
        tts_id: Option<&'tts_id str>,
        voice_id: Option<&'voice_id str>,
        hli_ids: Option<&'hli_ids str>,
        sink_id: Option<&'sink_id str>,
        keyword: Option<&'keyword str>,
        listening_item: Option<&'listening_item str>,
    ) -> Result<(), Error<StartDialogError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/dialog/start", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sourceId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ks_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("ksId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = stt_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sttId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = tts_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("ttsId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = voice_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("voiceId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = hli_ids {
            local_var_req_builder =
                local_var_req_builder.query(&[("hliIds", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sink_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sinkId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = keyword {
            local_var_req_builder =
                local_var_req_builder.query(&[("keyword", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = listening_item {
            local_var_req_builder =
                local_var_req_builder.query(&[("listeningItem", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = accept_language {
            local_var_req_builder =
                local_var_req_builder.header("Accept-Language", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<StartDialogError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn stop_dialog<'source_id>(
        &self,
        source_id: Option<&'source_id str>,
    ) -> Result<(), Error<StopDialogError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/dialog/stop", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = source_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("sourceId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<StopDialogError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn text_to_speech<'body, 'voiceid, 'sinkid, 'volume>(
        &self,
        body: &'body str,
        voiceid: Option<&'voiceid str>,
        sinkid: Option<&'sinkid str>,
        volume: Option<&'volume str>,
    ) -> Result<(), Error<TextToSpeechError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/voice/say", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = voiceid {
            local_var_req_builder =
                local_var_req_builder.query(&[("voiceid", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sinkid {
            local_var_req_builder =
                local_var_req_builder.query(&[("sinkid", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = volume {
            local_var_req_builder =
                local_var_req_builder.query(&[("volume", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<TextToSpeechError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`get_default_voice`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDefaultVoiceError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_voice_interpreter_by_uid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVoiceInterpreterByUidError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_voice_interpreters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVoiceInterpretersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_voices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVoicesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`interpret_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InterpretTextError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`interpret_text_by_default_interpreter`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InterpretTextByDefaultInterpreterError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`listen_and_answer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListenAndAnswerError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_dialog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDialogError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_dialog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDialogError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`text_to_speech`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TextToSpeechError {
    UnknownValue(serde_json::Value),
}
